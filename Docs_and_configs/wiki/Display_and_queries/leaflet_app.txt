Content-Type: text/x-zim-wiki
Wiki-Format: zim 0.4
Creation-Date: 2018-04-27T11:51:51+10:00

====== leaflet app ======
Created Friday 27 April 2018

I have created a leaflet shiny app that is written in R, but produces Javascript output for running in a browser. I am unsure how this can scale, but it is useful for demonstrating what is desired, and the R backend makes it easier to filter data etc and produce nifty graphs. It might be optimised better with shiny pro.

This page, in keeping with the nature of javascript, is piecemeal and hard to follow.

AS of 2018-02-09 [[Queries|queries]] are drawn directly from the Neo4j database for individual segments, but the display roads are precomputed due to computation demands. It is possible to prerender these to speed up the app (as Google does for its traffic information) but this makes the selection of roads difficult. 

As of 2018-12-03 the map no longer displays all the roads as vectors. Instead, a click on the map returns a lat lon which is then snapped to the nearest segment in a shapefile. The widget then displays that segment alone and queries the database. The roads available to be queried are displayed as vector tiles from Mapbox.

2019-07-17 - The mapbox tiles now have legends displayed. These are actually grapgs generated by the same criteria as the mapbox style. If that changes, so must the script legends.R

Queries on individual roads are also written to the database so we can track what segments are of particular interest.

Importantly the data is not properly anonymised. Stops, and some roads can identify the firms involved.

Below are some random points that have been learned.

Strings passed as labels etc will be rendered as html, meaning fonts etc can be set within them.

Leaflet usually thinks in lat longs, rather than long lat, but the R interface mitigates this, fortunately. Furthermore, it uses “lng”, not “lon”.

It is easier to do layer control from within leaflet than using shiny, but this has some draw backs, namely conditional inputs and the need to pass styles in the layer name (e.g "<font face = \"georgia\">Roads</font>" which can be awkward when using the layer name elsewhere, although it can be passed to a variable I guess. This is also true of pop up labels.

Styles are easy to do by putting a .css in a www/ subdirectory. This can be edited as needed, but I’ve used a bootstrapping one.

Tildes (~) are used when attributing a variable that is applied to objects.

Within the server function/script, and object including an input$ variable will be an observer, but I think it safer to make these explicit.

Colours are all RcolorBrewer based.

When using leafletproxy, the layer cannot be removed as a group, strangely, instead pass a vectors of ids for the shapes within it.

Polygons seem to block click events on all other objects, annoyingly.

I am struggling to make things full size. This will make the map full page but I cannot make it work with the roads and SA4s.

Ggplotly() does not like factors as labels – coerce to string. It also doesn’t like the subtitle argument in labs() and ignores it.
Ggplotly() also tends to size funnily compared to raw ggplots. This largely means one needs to call ggplotly() explicity (rather than relying on plotlyOutput()) so one can specify and exact size.

It’ll be hard to have custom hover text whilst using aes_string(). Maybe using get().

Error messages can be suppressed in the display but I’m not doing this at this stage.

R map shaper simplifies polygons and reduces their size considerably. This is why the displayed lines don’t follow the roads on the raster layer perfectly. That said ultimately we may have to consider a server that renders rasters (like the map tiles) because it is slow and I don’t know how it will scale.

Ggplotly craps itself with geom_ribbon() when there are NA values – including when Ggplot has created them because of a restricted scale. Hence there is code to eliminate rows where all the ribbon data is missing. I should report this bug.

Conditional panels rely on javascript notation for their boolean conditions.

The layercontrol provides input via the <mapname>_groups slot in input. That is input$<mapname>_groups in R and input.<mapname>_groups in JS.

The input.mymap_groups object will not exist until the layers have loaded, so the UI with conditional panels will return errors on the JS console until then.

The groups object is poorly (ie not at all) documented and is hard to build into observers. For instance I can make either the legend for the Trips or the legend for the Roads appear and disappear with the layercontrol, but not both at the same time.

Input$mymap_shape_click is NA initially.

Adding preferCanvas = TRUE to LeafletOptions() does appear to speed things up a bit.


When we get the server up and running I will attempt an interface that show the routes used between SA2s, but that requires intermediate data that was discarded when I returned from Data61.

Note that the SA4s may record a trip to and from an SA4 even if there is no visible stop. This is because all stops not attributed to a cluster have been filtered out.

The display can be sped up by simplifying the vectors using [[Display and queries:leaflet app:mapshaper|mapshaper]]
To scale we might need to render our own [[Display and queries:slippy maps|slippy maps]] tiles to replace the vector graphics.
